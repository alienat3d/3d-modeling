import { digitsOnly } from '../src/modules/helpers';
// * 1.0 Итак, у нас есть три формы на сайте, две одинаковые в секции "hero" и в модальном окне, а в секции "контакты" есть ещё дополнительно поле для ввода текста <textarea>, и нам нужно реализовать модуль отправки данных из этих форм. Нам нужен такой модуль, чтобы мы могли его вызвать из index.js для каждой формы по отдельно, передавая в этот модуль id каждой формы, чтобы указать, с какой именно формой ему нужно работать.
// ? 2.0 Но нам всё ещё не хватает получения данных из формы для отправки. Мы могли бы получить value каждого <input> из формы, составить объект из значений этих значений и затем отправить эти данные. Но это совсем неправильный подход. Рассмотрим более правильный подход сбора информации из формы для последующей отправки — воспользуемся FormData. ↓
// ? 3.4 Немного модифицируем параметры функции здесь и также в index.js, изменив на объект. Теперь мы там же сможем передавать в объект какое-то свойство, например массив с данными, в котором будут содержаться какие-то элементы, данные из которых нам нужно достать. 
// todo [3.5-3.7 см. index.js]
// ? 3.8 Мы также добавим в объект в параметрах someElems и присвоим по умолчанию ему пустой массив. ↓
// * 4.0 А теперь перейдём к важной теме валидации полей формы. Нам нужно запрещать отправку данных при пустых или неправильно введённых данных в поля формы. И тут есть несколько способов.
// 4.1 Мы можем навесить на каждый input с определённым атрибутом "name" свой обработчик события, например "input" и валидировать данные при их вводе. При вводе правильных данных добавлять элементу класс "success", а если данные неправильные (не проходят проверку регуляркой) — класс "error". ↓
// * 6.0 Сделаем также оповещение пользователя сообщением, что форма отправлена и очистку этого сообщения спустя некоторое время.
export const sendFormFunc = ({ formId, someElems = [] }) => {
	const form = document.querySelector(formId);

	// 6.1 Для этого мы создадим новый блок и несколько вариантов текста оповещения пользователя ↓
	const statusInfoBlock = document.createElement('div');
	const loadText = 'Началась загрузка данных…';
	const errorText = 'Произошла ошибка! Попробуйте снова.';
	const successText = 'Спасибо за заявку! Наш менеджер скоро с вами свяжется!';

	// 4.2 Создадим специальную функцию, которая будет проверять все наши инпуты на верность введённых данных "validate()" ↓
	// 4.4 Далее при каждом событии "submit" мы будем проверять функцией validate() наличие классов "success" на всех инпутах. И если хотя бы на одном из них не будет класса "success", то вернётся false и тогда отправка данных не произойдёт.
	// 4.5 Итак, создадим переменную let, которая изначально равна true. Потом у нас будет проверка, что если хотя бы один input не имеет класса 'success', то переменной success будет присвоено значение false. А затем, после проверки, мы возвращаем из функции значение переменной success. ↓
	const validate = (list) => {
		let success = true;

		// 4.7 Но если у нас нет отдельной функции, обрабатывающей регулярками инпуты, то сделать это можно здесь. Перебрать все инпуты и проверить методом test() их value. (И лично Александру этот вариант нравится больше.)
		/* list.forEach(input => {
			if (!input.classList.contains('success')) {
				success = false;
			}
		}); */

		return success;
	}

	/* const user = {
		name: 'Алексей',
		age: 37,
	} */

	// 1.1 Мы создадим функцию sendData(), которая аргументом будет принимать объект, который мы будем отправлять.
	// ? 1.2 Кстати, мы могли бы отправлять и на специальный файл server.php, но для этого нам нужно было бы развернуть PHP-сервер с соответствующим PHP-окружением. Но если лень с этим всем возиться, то проще и быстрее использовать JSONPlaceholder API, чтобы потестить свой код.
	// 1.3 Итак, вторым аргументом добавим настройки для нашего запроса, это методи и body (тело содержимого, что мы хотим переслать), который и будет нашим объектом в data, переведённая в JSON-формат методом JSON stringify()
	// 1.4 Здесь же, в методе then() конвертируем ответ от сервера из JSON в JS-объект методом json().
	// ? 2.2 Также нам необходимо добавить некоторые настройки для FormData, такие как headers.
	// ? 2.3 Ну и FormData мы не можем превращать в JSON-формат, т.к. это совершенно иной формат данных.
	// ? 2.4 FormData собирает со всех элементов формы, которые имеют атрибут "name".
	// ? 2.5 Многие API требуют формата данных именно в FormData, т.ч. нужно знать, как с ней работать, хотя от проекта к проекту форматы могут быть разными, зависит от бэкенда или API.
	/* 	const sendData = (data) => {
			return fetch('https://jsonplaceholder.typicode.com/posts', {
				method: 'POST',
				body: data,
				headers: {
					'Content-Type': 'multipart/form-data'
				}
			})
				.then(res => res.json());
		} */

	// form.addEventListener('submit', (evt) => {
	// evt.preventDefault();

	// ? 2.1 Итак, мы создаём экземпляр FormData и передаём в неё форму. Далее при отправке мы будем передавать её в sendData() ↑
	// const formData = new FormData(form);

	// 1.5 Сюда уже придут обработанные json() данные в data.
	// sendData(formData).then(data => console.log(data));
	// })

	// ? 3.2 Теперь не важно сколько будет инпутов в форме, пока в них есть атрибут "name", они все будут собираться FormData и потом преобразовывать в объект JSON. 
	// ? 3.3 Однако, иногда случается, что к отправляемым данным нам нужно присовокупить доп. свойства, к примеру, из каких-то обычных блоков их textContent. И для этого нам будет очень удобен именно объект formBody. ↑
	const sendData = (data) => {
		return fetch('https://jsonplaceholder.typicode.com/posts', {
			method: 'POST',
			body: JSON.stringify(data),
			headers: {
				'Content-Type': 'application/json'
			}
		})
			.then(res => res.json());
	}

	// * 8.0 Ну, и т.к. кто-то может по недосмотру подставить не тот id или верстальщик случайно удалить какой-то элемент, используемый в логике, то мы можем обезопасить себя, применив на отправку формы конструкцию "try...catch". Теперь, хотя и отправка формы с неправильно введённым id у нас работать больше не будет, зато весь остальной код останется рабочим, а в консоль выведется наша ошибка, которая подскажет, что и где пошло не так.
	try {
		if (!form) {
			throw new Error('Форма отправки не найдена');
		}

		form.addEventListener('submit', (evt) => {
			evt.preventDefault();

			// 4.3.0 Мы получим все элементы, которые надо валидировать в переменную formElements...
			// * Ну и под конец вынесем всю логику отправки данных в отдельную функцию submitForm() [будет в скрипте без конспекта]
			const formInputs = form.querySelectorAll('input');

			const formData = new FormData(form);

			// * 3.0 А теперь соберём из FormData объект. Для этого мы создаём пустой объект и переберём FormData при помощи forEach().
			const formBody = {};
			// 3.1 forEach() примет каждую итерацию два значения "value" & "key". Каждую итерацию мы будем записывать в объект formBody название свойства "key" и его значение "value".
			formData.forEach((value, key) => formBody[key] = value);

			// ? 3.8 Далее мы сделаем перебор этого массива с forEach(). Теперь мы будем вытаскивать содержимое по свойству textContent, если его тип 'block' или по value, если тип 'input'. Но сначала получим этот элемент по его id.
			// ? 3.9 На самом деле есть смысл даже сделать проверку, что добавлять мы будем, только если свойство textContent != 0, иначе добавлять не будем
			someElems.forEach(elem => {
				const element = document.querySelector(elem.id);
				if (elem.type === 'block' && +digitsOnly(element.textContent) !== 0) {
					// 3.10 В название свойства мы можем положить id элемента, ведь он уникален, а в значение element.textContent. Мы можем записывать в названия свойства как id, так и name, но лучше всё же работать с id в данных случаях
					formBody[elem.id] = +digitsOnly(element.textContent);
				} else if (elem.type === 'input') {
					formBody[elem.id] = element.value;
				}
			});

			// 6.2 Теперь запишем в текстовый контент подготовленный текст загрузки
			statusInfoBlock.textContent = loadText;
			// 6.3 И добавим его на страницу
			form.append(statusInfoBlock);

			// 4.3.1 [...] А затем в функцию validate() передадим весь этот список инпутов. ↑
			// console.log(validate(formElements));

			// 4.6 Ну и в итоге мы поместим запуск функции отправки данных на сервер sendData() в проверку функцией validate()
			// * 5. Было бы неплохо также очищать все инпуты, после отсылки формы. Сделать это лучше всего в then, промиса sendData(). Для этого просто переберём все инпуты формы и почистим их value. Инпуты мы уже получили в константу formElements.
			// 6.4 Ну и затем, когда получим ответ от сервера, то поменяем текстовый контент нашего оповещающего блока на сообщение об успехе.
			if (validate(formInputs)) {
				sendData(formBody)
					.then(data => {
						statusInfoBlock.textContent = successText;
						formInputs.forEach(input => input.value = '');
						console.log(data);
					})
					.catch(error => {
						statusInfoBlock.textContent = errorText;
					});
			} else {
				alert('Данные не валидны, проверьте ввод и попробуйте снова!');
			}
		})
	} catch (error) {
		console.error(error.message);
	}
}